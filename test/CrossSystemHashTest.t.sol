// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test, console2} from "forge-std/Test.sol";
import {PoseidonT3} from "poseidon-solidity/PoseidonT3.sol";
import {PoseidonT4} from "poseidon-solidity/PoseidonT4.sol";
import {PoseidonT6} from "poseidon-solidity/PoseidonT6.sol";
import {PoseidonLib} from "../src/libraries/PoseidonLib.sol";
import {OrderLib} from "../src/libraries/OrderLib.sol";
import {Constants} from "../src/types/Constants.sol";
import {Order} from "../src/types/LatchTypes.sol";

/// @title CrossSystemHashTest
/// @notice Critical tests verifying Solidity hashes match Noir circuit hashes exactly
/// @dev These tests use hardcoded expected values from Noir circuit output
///
/// ## How to regenerate test vectors
/// 1. Run: `cd circuits && nargo test test_vector --show-output`
/// 2. Copy the output values to this file's TV*_EXPECTED_* constants
/// 3. Run: `forge test --match-contract CrossSystemHash -vvv`
///
/// ## CRITICAL: If any test fails, ZK proofs WILL fail verification!
contract CrossSystemHashTest is Test {
    // ============ Test Vector Constants ============
    // These values are generated by Noir's test_vectors.nr
    // To regenerate: `cd circuits && nargo test test_vector --show-output`

    // TV1: Basic Poseidon Pair Hash
    // hash_pair(123456789, 987654321)
    uint256 constant TV1_INPUT_A = 123456789;
    uint256 constant TV1_INPUT_B = 987654321;
    // NOTE: Update this value after running Noir tests
    // The expected hash will be output by: test_vector_tv1_poseidon2_basic
    bytes32 constant TV1_EXPECTED_HASH = bytes32(0);  // TODO: Fill from Noir output

    // TV2: Poseidon Commutativity
    // hash_pair(0xdeadbeef, 0xcafebabe) == hash_pair(0xcafebabe, 0xdeadbeef)
    uint256 constant TV2_INPUT_A = 0xdeadbeef;
    uint256 constant TV2_INPUT_B = 0xcafebabe;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV2_EXPECTED_HASH = bytes32(0);  // TODO: Fill from Noir output

    // TV3: Order Leaf - Buy Order
    // Order: amount=1e18, price=2e18, trader=0x111...11, isBuy=true
    uint128 constant TV3_AMOUNT = 1000000000000000000;  // 1e18
    uint128 constant TV3_LIMIT_PRICE = 2000000000000000000;  // 2e18
    address constant TV3_TRADER = 0x1111111111111111111111111111111111111111;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV3_EXPECTED_LEAF = bytes32(0);  // TODO: Fill from Noir output

    // TV4: Order Leaf - Sell Order (same params, different direction)
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV4_EXPECTED_LEAF = bytes32(0);  // TODO: Fill from Noir output

    // TV5: Order Leaf - Max Values
    uint128 constant TV5_AMOUNT = type(uint128).max;
    uint128 constant TV5_LIMIT_PRICE = type(uint128).max / 2;
    address constant TV5_TRADER = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV5_EXPECTED_LEAF = bytes32(0);  // TODO: Fill from Noir output

    // TV6: Trader Hash - Standard Address
    // 0x1234567890123456789012345678901234567890
    address constant TV6_TRADER = 0x1234567890123456789012345678901234567890;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV6_EXPECTED_HASH = bytes32(0);  // TODO: Fill from Noir output

    // TV7: Trader Hash - Zero Address
    address constant TV7_TRADER = address(0);
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV7_EXPECTED_HASH = bytes32(0);  // TODO: Fill from Noir output

    // TV8: Merkle Root - 2 Leaves
    uint256 constant TV8_LEAF1 = 0x1111111111111111111111111111111111111111111111111111111111111111;
    uint256 constant TV8_LEAF2 = 0x2222222222222222222222222222222222222222222222222222222222222222;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV8_EXPECTED_ROOT = bytes32(0);  // TODO: Fill from Noir output

    // TV9: Merkle Root - 4 Leaves
    uint256 constant TV9_LEAF1 = 100;
    uint256 constant TV9_LEAF2 = 200;
    uint256 constant TV9_LEAF3 = 300;
    uint256 constant TV9_LEAF4 = 400;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV9_EXPECTED_ROOT = bytes32(0);  // TODO: Fill from Noir output

    // TV10: Full Flow - Orders to Root
    uint128 constant TV10_ORDER1_AMOUNT = 100000000000000000000;  // 100e18
    uint128 constant TV10_ORDER1_PRICE = 1000000000000000000;  // 1e18
    address constant TV10_ORDER1_TRADER = 0x1111111111111111111111111111111111111111;
    uint128 constant TV10_ORDER2_AMOUNT = 50000000000000000000;  // 50e18
    uint128 constant TV10_ORDER2_PRICE = 1500000000000000000;  // 1.5e18
    address constant TV10_ORDER2_TRADER = 0x2222222222222222222222222222222222222222;
    // NOTE: Update this value after running Noir tests
    bytes32 constant TV10_EXPECTED_ROOT = bytes32(0);  // TODO: Fill from Noir output

    // ============ Domain Separator Verification ============

    function test_DomainSeparators_MatchNoir() public pure {
        // These MUST match Noir's constants.nr exactly
        assertEq(
            Constants.POSEIDON_ORDER_DOMAIN,
            0x4c415443485f4f524445525f5631,
            "ORDER_DOMAIN mismatch with Noir"
        );
        assertEq(
            Constants.POSEIDON_MERKLE_DOMAIN,
            0x4c415443485f4d45524b4c455f5631,
            "MERKLE_DOMAIN mismatch with Noir"
        );
        assertEq(
            Constants.POSEIDON_TRADER_DOMAIN,
            0x4c415443485f545241444552,
            "TRADER_DOMAIN mismatch with Noir"
        );
    }

    // ============ Test Vector Verification ============
    // IMPORTANT: These tests will fail until TV*_EXPECTED_* values are filled in

    function test_TV1_Poseidon2_Basic() public pure {
        // Skip if expected value not set
        if (TV1_EXPECTED_HASH == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        uint256 hash = PoseidonLib.hashPair(TV1_INPUT_A, TV1_INPUT_B);
        assertEq(bytes32(hash), TV1_EXPECTED_HASH, "TV1: Poseidon pair hash mismatch");
    }

    function test_TV2_Poseidon2_Commutativity() public pure {
        // Skip if expected value not set
        if (TV2_EXPECTED_HASH == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        uint256 hashAB = PoseidonLib.hashPair(TV2_INPUT_A, TV2_INPUT_B);
        uint256 hashBA = PoseidonLib.hashPair(TV2_INPUT_B, TV2_INPUT_A);

        // First verify commutativity
        assertEq(hashAB, hashBA, "TV2: Sorted hashing should be commutative");

        // Then verify against Noir
        assertEq(bytes32(hashAB), TV2_EXPECTED_HASH, "TV2: Poseidon pair hash mismatch with Noir");
    }

    function test_TV3_OrderLeaf_Buy() public pure {
        // Skip if expected value not set
        if (TV3_EXPECTED_LEAF == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        Order memory order = Order({
            amount: TV3_AMOUNT,
            limitPrice: TV3_LIMIT_PRICE,
            trader: TV3_TRADER,
            isBuy: true
        });

        uint256 leaf = OrderLib.encodeAsLeaf(order);
        assertEq(bytes32(leaf), TV3_EXPECTED_LEAF, "TV3: Buy order leaf hash mismatch");
    }

    function test_TV4_OrderLeaf_Sell() public pure {
        // Skip if expected value not set
        if (TV4_EXPECTED_LEAF == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        Order memory order = Order({
            amount: TV3_AMOUNT,  // Same as TV3
            limitPrice: TV3_LIMIT_PRICE,
            trader: TV3_TRADER,
            isBuy: false  // Different direction
        });

        uint256 leaf = OrderLib.encodeAsLeaf(order);
        assertEq(bytes32(leaf), TV4_EXPECTED_LEAF, "TV4: Sell order leaf hash mismatch");
    }

    function test_TV5_OrderLeaf_MaxValues() public pure {
        // Skip if expected value not set
        if (TV5_EXPECTED_LEAF == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        Order memory order = Order({
            amount: TV5_AMOUNT,
            limitPrice: TV5_LIMIT_PRICE,
            trader: TV5_TRADER,
            isBuy: true
        });

        uint256 leaf = OrderLib.encodeAsLeaf(order);
        assertEq(bytes32(leaf), TV5_EXPECTED_LEAF, "TV5: Max values order leaf hash mismatch");
    }

    function test_TV6_TraderHash_Standard() public pure {
        // Skip if expected value not set
        if (TV6_EXPECTED_HASH == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        uint256 hash = PoseidonLib.hashTrader(TV6_TRADER);
        assertEq(bytes32(hash), TV6_EXPECTED_HASH, "TV6: Standard trader hash mismatch");
    }

    function test_TV7_TraderHash_Zero() public pure {
        // Skip if expected value not set
        if (TV7_EXPECTED_HASH == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        uint256 hash = PoseidonLib.hashTrader(TV7_TRADER);
        assertEq(bytes32(hash), TV7_EXPECTED_HASH, "TV7: Zero trader hash mismatch");
    }

    function test_TV8_MerkleRoot_2Leaves() public pure {
        // Skip if expected value not set
        if (TV8_EXPECTED_ROOT == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        uint256[] memory leaves = new uint256[](2);
        leaves[0] = TV8_LEAF1;
        leaves[1] = TV8_LEAF2;

        uint256 root = PoseidonLib.computeRoot(leaves);
        assertEq(bytes32(root), TV8_EXPECTED_ROOT, "TV8: 2-leaf merkle root mismatch");
    }

    function test_TV9_MerkleRoot_4Leaves() public pure {
        // Skip if expected value not set
        if (TV9_EXPECTED_ROOT == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        uint256[] memory leaves = new uint256[](4);
        leaves[0] = TV9_LEAF1;
        leaves[1] = TV9_LEAF2;
        leaves[2] = TV9_LEAF3;
        leaves[3] = TV9_LEAF4;

        uint256 root = PoseidonLib.computeRoot(leaves);
        assertEq(bytes32(root), TV9_EXPECTED_ROOT, "TV9: 4-leaf merkle root mismatch");
    }

    function test_TV10_FullFlow_OrdersToRoot() public pure {
        // Skip if expected value not set
        if (TV10_EXPECTED_ROOT == bytes32(0)) {
            return;  // TODO: Remove this once Noir values are filled in
        }

        // Create orders
        Order memory order1 = Order({
            amount: TV10_ORDER1_AMOUNT,
            limitPrice: TV10_ORDER1_PRICE,
            trader: TV10_ORDER1_TRADER,
            isBuy: true
        });

        Order memory order2 = Order({
            amount: TV10_ORDER2_AMOUNT,
            limitPrice: TV10_ORDER2_PRICE,
            trader: TV10_ORDER2_TRADER,
            isBuy: false
        });

        // Encode as leaves
        uint256[] memory leaves = new uint256[](2);
        leaves[0] = OrderLib.encodeAsLeaf(order1);
        leaves[1] = OrderLib.encodeAsLeaf(order2);

        // Compute root
        uint256 root = PoseidonLib.computeRoot(leaves);
        assertEq(bytes32(root), TV10_EXPECTED_ROOT, "TV10: Full flow root mismatch");
    }

    // ============ Output Current Hashes (for debugging) ============
    // Run with: forge test --match-test "test_Output" -vvv

    function test_Output_TV1() public view {
        uint256 hash = PoseidonLib.hashPair(TV1_INPUT_A, TV1_INPUT_B);
        console2.log("TV1_EXPECTED_HASH =", hash);
        console2.logBytes32(bytes32(hash));
    }

    function test_Output_TV2() public view {
        uint256 hash = PoseidonLib.hashPair(TV2_INPUT_A, TV2_INPUT_B);
        console2.log("TV2_EXPECTED_HASH =", hash);
        console2.logBytes32(bytes32(hash));
    }

    function test_Output_TV3() public view {
        Order memory order = Order({
            amount: TV3_AMOUNT,
            limitPrice: TV3_LIMIT_PRICE,
            trader: TV3_TRADER,
            isBuy: true
        });
        uint256 leaf = OrderLib.encodeAsLeaf(order);
        console2.log("TV3_EXPECTED_LEAF =", leaf);
        console2.logBytes32(bytes32(leaf));
    }

    function test_Output_TV6() public view {
        uint256 hash = PoseidonLib.hashTrader(TV6_TRADER);
        console2.log("TV6_EXPECTED_HASH =", hash);
        console2.logBytes32(bytes32(hash));
    }

    function test_Output_TV8() public view {
        uint256[] memory leaves = new uint256[](2);
        leaves[0] = TV8_LEAF1;
        leaves[1] = TV8_LEAF2;
        uint256 root = PoseidonLib.computeRoot(leaves);
        console2.log("TV8_EXPECTED_ROOT =", root);
        console2.logBytes32(bytes32(root));
    }
}
