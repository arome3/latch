// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test, console} from "forge-std/Test.sol";
import {LatchHook} from "../src/LatchHook.sol";
import {BatchVerifier} from "../src/verifier/BatchVerifier.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "@uniswap/v4-core/src/types/PoolId.sol";
import {Currency} from "@uniswap/v4-core/src/types/Currency.sol";
import {
    PoolMode,
    BatchPhase,
    PoolConfig,
    RevealSlot,
    Claimable,
    ClaimStatus,
    SettledBatchData
} from "../src/types/LatchTypes.sol";
import {Constants} from "../src/types/Constants.sol";
import {
    Latch__PIBatchIdMismatch,
    Latch__PICountMismatch,
    Latch__PIFeeMismatch,
    Latch__InvalidProof
} from "../src/types/Errors.sol";
import {IWhitelistRegistry} from "../src/interfaces/IWhitelistRegistry.sol";
import {IBatchVerifier} from "../src/interfaces/IBatchVerifier.sol";
import {BaseHook} from "@uniswap/v4-periphery/src/utils/BaseHook.sol";
import {ERC20Mock} from "./mocks/ERC20Mock.sol";

// ============ Mocks ============

/// @title MockPoolManager for E2E tests
contract MockPoolManager {}

/// @title MockWhitelistRegistry for E2E tests
contract MockWhitelistRegistry is IWhitelistRegistry {
    bytes32 public globalWhitelistRoot;

    function setGlobalRoot(bytes32 root) external {
        bytes32 oldRoot = globalWhitelistRoot;
        globalWhitelistRoot = root;
        emit GlobalWhitelistRootUpdated(oldRoot, root);
    }

    function isWhitelisted(address, bytes32, bytes32[] calldata) external pure returns (bool) {
        return true;
    }

    function isWhitelistedGlobal(address, bytes32[] calldata) external pure returns (bool) {
        return true;
    }

    function requireWhitelisted(address, bytes32, bytes32[] calldata) external pure {}

    function getEffectiveRoot(bytes32 poolRoot) external view returns (bytes32) {
        return poolRoot != bytes32(0) ? poolRoot : globalWhitelistRoot;
    }

    function computeLeaf(address account) external pure returns (bytes32) {
        return keccak256(abi.encodePacked(account));
    }
}

/// @title TestLatchHook for E2E tests
/// @dev Bypasses hook address validation
contract TestLatchHook is LatchHook {
    using PoolIdLibrary for PoolKey;

    constructor(
        IPoolManager _poolManager,
        IWhitelistRegistry _whitelistRegistry,
        IBatchVerifier _batchVerifier,
        address _owner
    ) LatchHook(_poolManager, _whitelistRegistry, _batchVerifier, _owner) {}

    function validateHookAddress(BaseHook) internal pure override {}

    receive() external payable {}
}

/// @title E2EProofVerificationTest
/// @notice End-to-end tests using real ZK proofs generated by the Noir circuit
/// @dev Proof artifacts are pre-generated via `script/prove.sh` and stored in
///      `circuits/target/proof/`. The test deploys the real HonkVerifier (not a mock)
///      and verifies that the full pipeline works: commit → reveal → settle with ZK proof.
///
///      Prover.toml values used to generate the proof:
///      - Buyer:  0x1111...1111, amount=100, limitPrice=1000, isBuy=true
///      - Seller: 0x2222...2222, amount=100, limitPrice=900,  isBuy=false
///      - clearingPrice=900, fills=[100, 100, 0...], feeRate=30, protocolFee=0
contract E2EProofVerificationTest is Test {
    using PoolIdLibrary for PoolKey;

    TestLatchHook public hook;
    BatchVerifier public batchVerifier;
    ERC20Mock public token0;
    ERC20Mock public token1;
    PoolKey public poolKey;
    PoolId public poolId;

    // Trader addresses matching Prover.toml
    address constant BUYER = 0x1111111111111111111111111111111111111111;
    address constant SELLER = 0x2222222222222222222222222222222222222222;
    address constant SOLVER = address(0x3001);

    // Phase durations
    uint32 constant COMMIT_DURATION = 100;
    uint32 constant REVEAL_DURATION = 100;
    uint32 constant SETTLE_DURATION = 100;
    uint32 constant CLAIM_DURATION = 100;

    // Salts for commitments (arbitrary — salts are not in the proof)
    bytes32 constant BUYER_SALT = keccak256("e2e_buyer_salt");
    bytes32 constant SELLER_SALT = keccak256("e2e_seller_salt");

    // Proof artifacts path
    string constant PROOF_PATH = "circuits/target/proof/proof";
    string constant PUBLIC_INPUTS_PATH = "circuits/target/proof/public_inputs";

    function setUp() public {
        // Deploy mocks
        MockPoolManager pm = new MockPoolManager();
        MockWhitelistRegistry wr = new MockWhitelistRegistry();

        // Deploy real HonkVerifier (28KB — exceeds EVM limit but Foundry allows it in tests)
        address honkVerifier = deployCode("HonkVerifier.sol:HonkVerifier");

        // Deploy real BatchVerifier wrapping HonkVerifier
        batchVerifier = new BatchVerifier(honkVerifier, address(this), true);

        // Deploy tokens
        token0 = new ERC20Mock("Token0", "TK0", 18);
        token1 = new ERC20Mock("Token1", "TK1", 18);

        // Deploy hook with REAL verifier (not a mock)
        hook = new TestLatchHook(
            IPoolManager(address(pm)),
            IWhitelistRegistry(address(wr)),
            IBatchVerifier(address(batchVerifier)),
            address(this)
        );

        // Set up pool key
        poolKey = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: hook
        });
        poolId = poolKey.toId();

        // Disable batch start bond
        hook.setBatchStartBond(0);

        // Fund traders with token1 (quote currency for deposits)
        token1.mint(BUYER, 10_000);
        token1.mint(SELLER, 10_000);

        vm.prank(BUYER);
        token1.approve(address(hook), type(uint256).max);
        vm.prank(SELLER);
        token1.approve(address(hook), type(uint256).max);

        // Fund solver with token0 (provides liquidity for buy order fills)
        token0.mint(SOLVER, 10_000);
        vm.prank(SOLVER);
        token0.approve(address(hook), type(uint256).max);
    }

    // ============ Helpers ============

    /// @notice Compute commitment hash matching LatchHook._computeCommitmentHash
    function _commitmentHash(
        address trader,
        uint128 amount,
        uint128 limitPrice,
        bool isBuy,
        bytes32 salt
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(Constants.COMMITMENT_DOMAIN, trader, amount, limitPrice, isBuy, salt));
    }

    /// @notice Load proof bytes from pre-generated artifact
    function _loadProof() internal view returns (bytes memory) {
        return vm.readFileBinary(PROOF_PATH);
    }

    /// @notice Load and parse 25 public inputs from binary file (32 bytes each, big-endian)
    function _loadPublicInputs() internal view returns (bytes32[] memory) {
        bytes memory raw = vm.readFileBinary(PUBLIC_INPUTS_PATH);
        require(raw.length == 25 * 32, "unexpected public inputs size");

        bytes32[] memory inputs = new bytes32[](25);
        for (uint256 i = 0; i < 25; i++) {
            bytes32 value;
            assembly ("memory-safe") {
                value := mload(add(raw, add(32, mul(i, 32))))
            }
            inputs[i] = value;
        }
        return inputs;
    }

    /// @notice Set up a batch through commit and reveal phases with values matching Prover.toml
    function _setupBatch() internal {
        // Configure pool: PERMISSIONLESS, feeRate=30 (matching proof)
        PoolConfig memory config = PoolConfig({
            mode: PoolMode.PERMISSIONLESS,
            commitDuration: COMMIT_DURATION,
            revealDuration: REVEAL_DURATION,
            settleDuration: SETTLE_DURATION,
            claimDuration: CLAIM_DURATION,
            feeRate: 30,
            whitelistRoot: bytes32(0)
        });
        hook.configurePool(poolKey, config);

        // Start batch (batchId becomes 1)
        hook.startBatch(poolKey);

        // === COMMIT PHASE ===
        // Buyer: amount=100, limitPrice=1000, isBuy=true
        bytes32 buyerHash = _commitmentHash(BUYER, 100, 1000, true, BUYER_SALT);
        vm.prank(BUYER);
        hook.commitOrder(poolKey, buyerHash, 100, new bytes32[](0));

        // Seller: amount=100, limitPrice=900, isBuy=false
        bytes32 sellerHash = _commitmentHash(SELLER, 100, 900, false, SELLER_SALT);
        vm.prank(SELLER);
        hook.commitOrder(poolKey, sellerHash, 100, new bytes32[](0));

        // === REVEAL PHASE (batch uses block.number, not timestamp) ===
        vm.roll(block.number + COMMIT_DURATION + 1);

        // Buyer reveals first (must match revealedSlots[0] = buyer, matching fills[0])
        vm.prank(BUYER);
        hook.revealOrder(poolKey, 100, 1000, true, BUYER_SALT);

        // Seller reveals second (revealedSlots[1] = seller, matching fills[1])
        vm.prank(SELLER);
        hook.revealOrder(poolKey, 100, 900, false, SELLER_SALT);

        // === Advance to SETTLE PHASE ===
        vm.roll(block.number + REVEAL_DURATION + 1);
    }

    // ============ Core E2E Tests ============

    /// @notice Full end-to-end: real ZK proof settles a batch through the real HonkVerifier
    function test_e2e_realProofSettlesBatch() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Sanity: verify public inputs match expected values from Prover.toml
        assertEq(uint256(publicInputs[0]), 1, "PI[0] batchId");
        assertEq(uint256(publicInputs[1]), 900, "PI[1] clearingPrice");
        assertEq(uint256(publicInputs[2]), 100, "PI[2] buyVolume");
        assertEq(uint256(publicInputs[3]), 100, "PI[3] sellVolume");
        assertEq(uint256(publicInputs[4]), 2, "PI[4] orderCount");
        assertEq(uint256(publicInputs[7]), 30, "PI[7] feeRate");
        assertEq(uint256(publicInputs[8]), 0, "PI[8] protocolFee");
        assertEq(uint256(publicInputs[9]), 100, "PI[9] fills[0]");
        assertEq(uint256(publicInputs[10]), 100, "PI[10] fills[1]");

        // Settle with real proof — this calls HonkVerifier.verify() on-chain
        vm.prank(SOLVER);
        hook.settleBatch(poolKey, proof, publicInputs);

        // Verify batch transitioned to settled state
        SettledBatchData memory settled = hook.getSettledBatch(poolId, 1);
        assertEq(settled.clearingPrice, 900, "settled clearingPrice");
        assertEq(settled.totalBuyVolume, 100, "settled buyVolume");
        assertEq(settled.totalSellVolume, 100, "settled sellVolume");
    }

    /// @notice Verify claimable amounts are correct after real proof settlement
    function test_e2e_claimablesCorrectAfterSettlement() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        vm.prank(SOLVER);
        hook.settleBatch(poolKey, proof, publicInputs);

        // Buyer: fill=100 of token0, payment = (100 * 900) / 1e18 = 0 (small values)
        // So buyer gets: amount0=100 (fill), amount1=100 (full deposit refund since payment rounds to 0)
        (Claimable memory buyerClaim,) = hook.getClaimable(poolId, 1, BUYER);
        assertEq(buyerClaim.amount0, 100, "buyer should receive 100 token0 (fill)");
        assertEq(buyerClaim.amount1, 100, "buyer should get full deposit refund (payment rounds to 0)");

        // Seller: fill=100, payment = (100 * 900) / 1e18 = 0 (small values)
        // So seller gets: amount0=0, amount1 = 0 + (100 - 100) = 0
        (Claimable memory sellerClaim,) = hook.getClaimable(poolId, 1, SELLER);
        assertEq(sellerClaim.amount0, 0, "seller should receive 0 token0");
        assertEq(sellerClaim.amount1, 0, "seller payment and refund both 0 with small values");
    }

    /// @notice Verify proof bytes are correct length
    function test_e2e_proofArtifactsSanityCheck() public view {
        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Proof should be non-empty
        assertTrue(proof.length > 0, "proof should not be empty");
        // Public inputs should have exactly 25 elements
        assertEq(publicInputs.length, 25, "should have 25 public inputs");
        // All fills beyond index 1 should be zero (only 2 orders)
        for (uint256 i = 11; i < 25; i++) {
            assertEq(uint256(publicInputs[i]), 0, "unused fill should be zero");
        }
    }

    // ============ Negative E2E Tests ============

    /// @notice Tampered clearing price → proof verification fails
    function test_e2e_tamperedClearingPrice_failsProof() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Tamper: change clearing price from 900 to 901
        publicInputs[1] = bytes32(uint256(901));

        vm.prank(SOLVER);
        vm.expectRevert(); // HonkVerifier rejects tampered inputs
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    /// @notice Tampered fill → proof verification fails
    function test_e2e_tamperedFill_failsProof() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Tamper: inflate buyer fill from 100 to 200
        publicInputs[9] = bytes32(uint256(200));

        vm.prank(SOLVER);
        vm.expectRevert(); // HonkVerifier rejects tampered inputs
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    /// @notice Tampered orders root → proof verification fails
    function test_e2e_tamperedOrdersRoot_failsProof() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Tamper: change orders root to an arbitrary value
        publicInputs[5] = bytes32(uint256(0xdeadbeef));

        vm.prank(SOLVER);
        vm.expectRevert(); // HonkVerifier rejects tampered inputs
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    // ============ Chain-State Validation Tests (caught before proof verification) ============

    /// @notice Wrong batchId → caught by on-chain PI validation
    function test_e2e_wrongBatchId_caughtOnChain() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Tamper: change batchId from 1 to 2
        publicInputs[0] = bytes32(uint256(2));

        vm.prank(SOLVER);
        vm.expectRevert(abi.encodeWithSelector(Latch__PIBatchIdMismatch.selector, 1, 2));
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    /// @notice Wrong order count → caught by on-chain PI validation
    function test_e2e_wrongOrderCount_caughtOnChain() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Tamper: change orderCount from 2 to 3
        publicInputs[4] = bytes32(uint256(3));

        vm.prank(SOLVER);
        vm.expectRevert(abi.encodeWithSelector(Latch__PICountMismatch.selector, 2, 3));
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    /// @notice Wrong fee rate → caught by on-chain PI validation
    function test_e2e_wrongFeeRate_caughtOnChain() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Tamper: change feeRate from 30 to 50
        publicInputs[7] = bytes32(uint256(50));

        vm.prank(SOLVER);
        vm.expectRevert(abi.encodeWithSelector(Latch__PIFeeMismatch.selector, 30, 50));
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    // ============ Verifier Status Tests ============

    /// @notice Disabled verifier rejects all proofs
    function test_e2e_disabledVerifier_rejectsProof() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Disable the real verifier
        batchVerifier.disable();

        vm.prank(SOLVER);
        vm.expectRevert(); // VerifierDisabled
        hook.settleBatch(poolKey, proof, publicInputs);
    }

    /// @notice Re-enabled verifier accepts valid proofs again
    function test_e2e_reenabledVerifier_acceptsProof() public {
        _setupBatch();

        bytes memory proof = _loadProof();
        bytes32[] memory publicInputs = _loadPublicInputs();

        // Disable then re-enable
        batchVerifier.disable();
        batchVerifier.enable();

        vm.prank(SOLVER);
        hook.settleBatch(poolKey, proof, publicInputs);

        // Should have settled successfully
        SettledBatchData memory settled = hook.getSettledBatch(poolId, 1);
        assertEq(settled.clearingPrice, 900, "should settle after re-enable");
    }
}
