#!/usr/bin/env node
// =============================================================================
// Latch - Verifier Post-Processor
// =============================================================================
// Post-processes the auto-generated Barretenberg verifier to create:
// 1. UltraVerifier.sol - Renamed auto-generated verifier
// 2. BatchVerifier.sol - IBatchVerifier wrapper contract
// 3. PublicInputsLib.sol - Public inputs encoding/validation library
//
// Usage: node tools/post-process-verifier.js
// =============================================================================

const fs = require('fs');
const path = require('path');

// Configuration
const PROJECT_ROOT = path.resolve(__dirname, '..');
const VERIFIER_DIR = path.join(PROJECT_ROOT, 'src', 'verifier');
const GENERATED_VERIFIER = path.join(VERIFIER_DIR, 'BatchVerifier.sol.tmp');

// Public inputs configuration (MUST match Noir circuit and IBatchVerifier)
const PUBLIC_INPUTS = [
    { index: 0, name: 'batchId', type: 'bytes32', description: 'Unique batch identifier' },
    { index: 1, name: 'clearingPrice', type: 'bytes32', description: 'Computed uniform clearing price' },
    { index: 2, name: 'totalBuyVolume', type: 'bytes32', description: 'Sum of matched buy order amounts' },
    { index: 3, name: 'totalSellVolume', type: 'bytes32', description: 'Sum of matched sell order amounts' },
    { index: 4, name: 'orderCount', type: 'bytes32', description: 'Number of orders in the batch' },
    { index: 5, name: 'ordersRoot', type: 'bytes32', description: 'Merkle root of all orders' },
    { index: 6, name: 'whitelistRoot', type: 'bytes32', description: 'Merkle root of whitelist (0 if PERMISSIONLESS)' },
    { index: 7, name: 'feeRate', type: 'bytes32', description: 'Fee rate in basis points (0-1000)' },
    { index: 8, name: 'protocolFee', type: 'bytes32', description: 'Computed protocol fee amount' },
];

const NUM_PUBLIC_INPUTS = PUBLIC_INPUTS.length;

// =============================================================================
// Main
// =============================================================================

function main() {
    console.log('');
    console.log('==============================================');
    console.log('  Latch Verifier Post-Processor');
    console.log('==============================================');
    console.log('');

    // Ensure output directory exists
    if (!fs.existsSync(VERIFIER_DIR)) {
        fs.mkdirSync(VERIFIER_DIR, { recursive: true });
    }

    // Check if there's a generated verifier to process
    const hasGeneratedVerifier = fs.existsSync(GENERATED_VERIFIER);

    if (hasGeneratedVerifier) {
        // Step 1: Process auto-generated verifier into UltraVerifier.sol
        console.log('[1/3] Processing auto-generated verifier...');
        processUltraVerifier();
        console.log('      -> Created UltraVerifier.sol');
    } else {
        console.log('[1/3] No auto-generated verifier found, creating placeholder...');
        createPlaceholderUltraVerifier();
        console.log('      -> Created placeholder UltraVerifier.sol');
    }

    // Step 2: Generate BatchVerifier.sol wrapper
    console.log('[2/3] Generating BatchVerifier.sol...');
    generateBatchVerifier();
    console.log('      -> Created BatchVerifier.sol');

    // Step 3: Generate PublicInputsLib.sol
    console.log('[3/3] Generating PublicInputsLib.sol...');
    generatePublicInputsLib();
    console.log('      -> Created PublicInputsLib.sol');

    console.log('');
    console.log('==============================================');
    console.log('  Post-processing complete!');
    console.log('==============================================');
    console.log('');
    console.log('Generated files:');
    console.log(`  - ${path.relative(PROJECT_ROOT, path.join(VERIFIER_DIR, 'UltraVerifier.sol'))}`);
    console.log(`  - ${path.relative(PROJECT_ROOT, path.join(VERIFIER_DIR, 'BatchVerifier.sol'))}`);
    console.log(`  - ${path.relative(PROJECT_ROOT, path.join(VERIFIER_DIR, 'PublicInputsLib.sol'))}`);
    console.log('');
}

// =============================================================================
// UltraVerifier Processing
// =============================================================================

function processUltraVerifier() {
    let content = fs.readFileSync(GENERATED_VERIFIER, 'utf8');

    // Fix Solidity version compatibility (BB 3.0.0 generates ^0.8.27 which doesn't exist)
    content = content.replace(/pragma solidity \^0\.8\.27/g, 'pragma solidity ^0.8.26');
    content = content.replace(/pragma solidity >=0\.8\.21/g, 'pragma solidity ^0.8.26');

    // Add header comment if not present
    if (!content.includes('Auto-generated by Barretenberg')) {
        const lines = content.split('\n');
        const spdxIndex = lines.findIndex(l => l.includes('SPDX-License-Identifier'));
        if (spdxIndex >= 0) {
            lines.splice(spdxIndex + 1, 0, '// Auto-generated by Barretenberg - DO NOT EDIT');
            lines.splice(spdxIndex + 2, 0, '// This file is regenerated by: ./tools/generate-verifier.sh');
            content = lines.join('\n');
        }
    }

    // Note: BB 3.0.0 generates HonkVerifier contract name, which we keep as-is
    // BatchVerifier uses an interface (IHonkVerifier) to work with either HonkVerifier or mocks

    fs.writeFileSync(path.join(VERIFIER_DIR, 'UltraVerifier.sol'), content);

    // Remove the temp file
    fs.unlinkSync(GENERATED_VERIFIER);
}

function createPlaceholderUltraVerifier() {
    const content = `// SPDX-License-Identifier: MIT
// Placeholder UltraVerifier - Replace with auto-generated verifier
// Run: ./tools/generate-verifier.sh to generate the real verifier

pragma solidity ^0.8.26;

/// @title UltraVerifier
/// @notice Placeholder for the auto-generated Barretenberg UltraHonk verifier
/// @dev This file will be replaced when running generate-verifier.sh
contract UltraVerifier {
    /// @notice Verify an UltraHonk proof
    /// @param _proof The proof bytes
    /// @param _publicInputs Array of public inputs as bytes32
    /// @return True if valid (placeholder always returns true for testing)
    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external pure returns (bool) {
        // Suppress unused variable warnings
        _proof;
        _publicInputs;

        // Placeholder: always returns true
        // In production, this is replaced by the actual cryptographic verification
        return true;
    }
}
`;

    fs.writeFileSync(path.join(VERIFIER_DIR, 'UltraVerifier.sol'), content);
}

// =============================================================================
// BatchVerifier Generation
// =============================================================================

function generateBatchVerifier() {
    const content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {IBatchVerifier} from "../interfaces/IBatchVerifier.sol";
import {PublicInputsLib} from "./PublicInputsLib.sol";

/// @notice Interface for the underlying verifier contract
interface IHonkVerifier {
    function verify(bytes calldata proof, bytes32[] calldata publicInputs) external view returns (bool);
}

/// @title BatchVerifier
/// @notice IBatchVerifier implementation wrapping the auto-generated UltraHonk verifier
/// @dev This contract provides a stable interface while allowing verifier upgrades
///
/// ## Architecture
///
/// \`\`\`
/// IBatchVerifier (interface)
///        |
///        v
/// BatchVerifier (this contract) -- wraps --> IHonkVerifier (auto-generated)
///        |
///        v
/// PublicInputsLib (encoding/validation)
/// \`\`\`
///
/// ## Public Inputs (${NUM_PUBLIC_INPUTS} total, matching Noir circuit)
///
/// | Index | Field           | Description                                    |
/// |-------|-----------------|------------------------------------------------|
${PUBLIC_INPUTS.map(p => `/// |   ${p.index}   | ${p.name.padEnd(15)} | ${p.description.padEnd(46)} |`).join('\n')}
///
contract BatchVerifier is IBatchVerifier {
    // ============ Immutables ============

    /// @notice The underlying UltraHonk verifier
    IHonkVerifier public immutable ultraVerifier;

    /// @notice Whether the verifier is enabled
    /// @dev When disabled, verify() will revert
    bool public immutable enabled;

    // ============ Constants ============

    /// @notice Number of public inputs expected by the circuit
    uint256 public constant NUM_PUBLIC_INPUTS = ${NUM_PUBLIC_INPUTS};

    // ============ Constructor ============

    /// @notice Create a new BatchVerifier
    /// @param _ultraVerifier Address of the auto-generated UltraHonk verifier
    /// @param _enabled Whether verification is enabled (false for testing)
    constructor(address _ultraVerifier, bool _enabled) {
        ultraVerifier = IHonkVerifier(_ultraVerifier);
        enabled = _enabled;

        emit VerifierStatusChanged(_enabled);
    }

    // ============ IBatchVerifier Implementation ============

    /// @inheritdoc IBatchVerifier
    function verify(bytes calldata proof, bytes32[] calldata publicInputs)
        external
        view
        override
        returns (bool)
    {
        // Check if verifier is enabled
        if (!enabled) {
            revert VerifierDisabled();
        }

        // Validate public inputs length
        if (publicInputs.length != NUM_PUBLIC_INPUTS) {
            revert InvalidPublicInputsLength(NUM_PUBLIC_INPUTS, publicInputs.length);
        }

        // Validate public inputs format using library
        PublicInputsLib.validate(publicInputs);

        // Call the underlying verifier
        bool valid = ultraVerifier.verify(proof, publicInputs);

        if (!valid) {
            revert InvalidProof();
        }

        return true;
    }

    /// @inheritdoc IBatchVerifier
    function isEnabled() external view override returns (bool) {
        return enabled;
    }

    /// @inheritdoc IBatchVerifier
    function getPublicInputsCount() external pure override returns (uint256) {
        return NUM_PUBLIC_INPUTS;
    }

    // ============ Helper Functions ============

    /// @notice Encode proof public inputs into the expected format
    /// @param inputs Structured public inputs
    /// @return Array of bytes32 values in circuit order
    function encodePublicInputs(PublicInputsLib.ProofPublicInputs calldata inputs)
        external
        pure
        returns (bytes32[] memory)
    {
        return PublicInputsLib.encode(inputs);
    }

    /// @notice Decode bytes32 array into structured public inputs
    /// @param publicInputs Array of bytes32 values
    /// @return Structured public inputs
    function decodePublicInputs(bytes32[] calldata publicInputs)
        external
        pure
        returns (PublicInputsLib.ProofPublicInputs memory)
    {
        return PublicInputsLib.decode(publicInputs);
    }
}
`;

    fs.writeFileSync(path.join(VERIFIER_DIR, 'BatchVerifier.sol'), content);
}

// =============================================================================
// PublicInputsLib Generation
// =============================================================================

function generatePublicInputsLib() {
    const content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Constants} from "../types/Constants.sol";

/// @title PublicInputsLib
/// @notice Library for encoding, decoding, and validating ZK proof public inputs
/// @dev Ensures type safety and correct ordering of public inputs for the Noir circuit
///
/// ## Public Inputs Order (MUST match Noir circuit exactly)
///
/// | Index | Field           | Noir Type  | Solidity Type |
/// |-------|-----------------|------------|---------------|
${PUBLIC_INPUTS.map(p => `/// |   ${p.index}   | ${p.name.padEnd(15)} | pub Field  | ${p.type.padEnd(13)} |`).join('\n')}
///
library PublicInputsLib {
    // ============ Index Constants ============

${PUBLIC_INPUTS.map(p => `    /// @notice Index for ${p.name} in public inputs array
    uint256 internal constant IDX_${p.name.replace(/([A-Z])/g, '_$1').toUpperCase()} = ${p.index};
`).join('\n')}

    /// @notice Total number of public inputs
    uint256 internal constant NUM_PUBLIC_INPUTS = ${NUM_PUBLIC_INPUTS};

    // ============ Structs ============

    /// @notice Structured representation of proof public inputs
    /// @dev Field order matches the public inputs array indices
    struct ProofPublicInputs {
${PUBLIC_INPUTS.map(p => `        /// @notice [${p.index}] ${p.description}
        ${p.type} ${p.name};
`).join('')}    }

    // ============ Errors ============

    /// @notice Thrown when public inputs array has wrong length
    error InvalidPublicInputsLength(uint256 expected, uint256 actual);

    /// @notice Thrown when a public input value is invalid
    error InvalidPublicInputValue(uint256 index, bytes32 value, string reason);

    // ============ Encoding Functions ============

    /// @notice Encode structured inputs into bytes32 array
    /// @param inputs The structured public inputs
    /// @return publicInputs Array of bytes32 in circuit order
    function encode(ProofPublicInputs memory inputs) internal pure returns (bytes32[] memory publicInputs) {
        publicInputs = new bytes32[](NUM_PUBLIC_INPUTS);
${PUBLIC_INPUTS.map(p => `        publicInputs[${p.index}] = inputs.${p.name};`).join('\n')}
    }

    /// @notice Encode from individual values (convenience function)
    /// @return publicInputs Array of bytes32 in circuit order
    function encodeValues(
${PUBLIC_INPUTS.map((p, i) => `        ${p.type} ${p.name}${i < PUBLIC_INPUTS.length - 1 ? ',' : ''}`).join('\n')}
    ) internal pure returns (bytes32[] memory publicInputs) {
        publicInputs = new bytes32[](NUM_PUBLIC_INPUTS);
${PUBLIC_INPUTS.map(p => `        publicInputs[${p.index}] = ${p.name};`).join('\n')}
    }

    // ============ Decoding Functions ============

    /// @notice Decode bytes32 array into structured inputs
    /// @param publicInputs Array of bytes32 values
    /// @return inputs Structured public inputs
    function decode(bytes32[] memory publicInputs) internal pure returns (ProofPublicInputs memory inputs) {
        if (publicInputs.length != NUM_PUBLIC_INPUTS) {
            revert InvalidPublicInputsLength(NUM_PUBLIC_INPUTS, publicInputs.length);
        }

${PUBLIC_INPUTS.map(p => `        inputs.${p.name} = publicInputs[${p.index}];`).join('\n')}
    }

    // ============ Validation Functions ============

    /// @notice Validate public inputs format and bounds
    /// @dev Reverts with specific error if validation fails
    /// @param publicInputs Array of bytes32 values to validate
    function validate(bytes32[] memory publicInputs) internal pure {
        if (publicInputs.length != NUM_PUBLIC_INPUTS) {
            revert InvalidPublicInputsLength(NUM_PUBLIC_INPUTS, publicInputs.length);
        }

        // Validate feeRate is within bounds (0-1000 basis points)
        uint256 feeRate = uint256(publicInputs[IDX_FEE_RATE]);
        if (feeRate > Constants.MAX_FEE_RATE) {
            revert InvalidPublicInputValue(IDX_FEE_RATE, publicInputs[IDX_FEE_RATE], "feeRate exceeds maximum");
        }
    }

    /// @notice Validate public inputs match expected on-chain values
    /// @param publicInputs The public inputs to validate
    /// @param expectedBatchId Expected batch ID
    /// @param expectedOrderCount Expected number of orders
    /// @param expectedOrdersRoot Expected merkle root of orders
    /// @param expectedWhitelistRoot Expected whitelist root
    /// @param expectedFeeRate Expected fee rate
    function validateAgainstExpected(
        bytes32[] memory publicInputs,
        uint256 expectedBatchId,
        uint256 expectedOrderCount,
        bytes32 expectedOrdersRoot,
        bytes32 expectedWhitelistRoot,
        uint16 expectedFeeRate
    ) internal pure {
        // First run basic validation
        validate(publicInputs);

        // Validate batch ID
        if (uint256(publicInputs[IDX_BATCH_ID]) != expectedBatchId) {
            revert InvalidPublicInputValue(IDX_BATCH_ID, publicInputs[IDX_BATCH_ID], "batchId mismatch");
        }

        // Validate order count
        if (uint256(publicInputs[IDX_ORDER_COUNT]) != expectedOrderCount) {
            revert InvalidPublicInputValue(IDX_ORDER_COUNT, publicInputs[IDX_ORDER_COUNT], "orderCount mismatch");
        }

        // Validate orders root
        if (publicInputs[IDX_ORDERS_ROOT] != expectedOrdersRoot) {
            revert InvalidPublicInputValue(IDX_ORDERS_ROOT, publicInputs[IDX_ORDERS_ROOT], "ordersRoot mismatch");
        }

        // Validate whitelist root
        if (publicInputs[IDX_WHITELIST_ROOT] != expectedWhitelistRoot) {
            revert InvalidPublicInputValue(IDX_WHITELIST_ROOT, publicInputs[IDX_WHITELIST_ROOT], "whitelistRoot mismatch");
        }

        // Validate fee rate
        if (uint256(publicInputs[IDX_FEE_RATE]) != expectedFeeRate) {
            revert InvalidPublicInputValue(IDX_FEE_RATE, publicInputs[IDX_FEE_RATE], "feeRate mismatch");
        }

        // Validate protocol fee computation
        uint256 buyVolume = uint256(publicInputs[IDX_TOTAL_BUY_VOLUME]);
        uint256 sellVolume = uint256(publicInputs[IDX_TOTAL_SELL_VOLUME]);
        uint256 matchedVolume = buyVolume < sellVolume ? buyVolume : sellVolume;
        uint256 expectedProtocolFee = (matchedVolume * expectedFeeRate) / Constants.FEE_DENOMINATOR;

        if (uint256(publicInputs[IDX_PROTOCOL_FEE]) != expectedProtocolFee) {
            revert InvalidPublicInputValue(IDX_PROTOCOL_FEE, publicInputs[IDX_PROTOCOL_FEE], "protocolFee mismatch");
        }
    }

    // ============ Accessor Functions ============

    /// @notice Get batch ID from public inputs
    function getBatchId(bytes32[] memory publicInputs) internal pure returns (uint256) {
        return uint256(publicInputs[IDX_BATCH_ID]);
    }

    /// @notice Get clearing price from public inputs
    function getClearingPrice(bytes32[] memory publicInputs) internal pure returns (uint128) {
        return uint128(uint256(publicInputs[IDX_CLEARING_PRICE]));
    }

    /// @notice Get total buy volume from public inputs
    function getTotalBuyVolume(bytes32[] memory publicInputs) internal pure returns (uint128) {
        return uint128(uint256(publicInputs[IDX_TOTAL_BUY_VOLUME]));
    }

    /// @notice Get total sell volume from public inputs
    function getTotalSellVolume(bytes32[] memory publicInputs) internal pure returns (uint128) {
        return uint128(uint256(publicInputs[IDX_TOTAL_SELL_VOLUME]));
    }

    /// @notice Get order count from public inputs
    function getOrderCount(bytes32[] memory publicInputs) internal pure returns (uint256) {
        return uint256(publicInputs[IDX_ORDER_COUNT]);
    }

    /// @notice Get orders root from public inputs
    function getOrdersRoot(bytes32[] memory publicInputs) internal pure returns (bytes32) {
        return publicInputs[IDX_ORDERS_ROOT];
    }

    /// @notice Get whitelist root from public inputs
    function getWhitelistRoot(bytes32[] memory publicInputs) internal pure returns (bytes32) {
        return publicInputs[IDX_WHITELIST_ROOT];
    }

    /// @notice Get fee rate from public inputs
    function getFeeRate(bytes32[] memory publicInputs) internal pure returns (uint16) {
        return uint16(uint256(publicInputs[IDX_FEE_RATE]));
    }

    /// @notice Get protocol fee from public inputs
    function getProtocolFee(bytes32[] memory publicInputs) internal pure returns (uint256) {
        return uint256(publicInputs[IDX_PROTOCOL_FEE]);
    }

    /// @notice Get matched volume (min of buy and sell volumes)
    function getMatchedVolume(bytes32[] memory publicInputs) internal pure returns (uint128) {
        uint128 buyVol = getTotalBuyVolume(publicInputs);
        uint128 sellVol = getTotalSellVolume(publicInputs);
        return buyVol < sellVol ? buyVol : sellVol;
    }
}
`;

    fs.writeFileSync(path.join(VERIFIER_DIR, 'PublicInputsLib.sol'), content);
}

// Run main
main();
